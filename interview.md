**ООП**

## Главное

* Инкапсулируйте все, что может изменяться;
* Уделяйте больше внимания интерфейсам, а не их реализациям;
* Каждый класс в вашем приложении должен иметь только одно назначение;
* Классы — это их поведение и функциональность.

---

* Абстракция — отделение концепции от ее экземпляра;
* Полиморфизм — реализация задач одной и той же идеи разными способами;
* Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
* Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.

---

## Наследование

Классы наследуют какие-то характеристики от другого класса.

**Например,** у нас есть класс **человек** , внутри которого есть какие-то данные (имя, пол, возраст и т.д.),  а еще какие-то функции, например, функция **ходьбы**.

Но младенец, взрослый и старик будут ходить по-разному. Но все они могут быть опмисаны одним классом человек (т.к. у них одни и те же параметры и функции), но некоторые функции у них работают по-разному. Можно ввести отдельные классы Младенец, Взрослый и Старик, которые унаследуют класс Человек, но внутри каждого класса будет реализована своя функция ходьбы.

```
Chelovek [] obj = new Chelovek[]
{
    new Mladenec
    new Vzroslyi
    new Starik

    GameLoop()
    {
        foreach (Chelovek o in obj)
        o.Walking();
    }
}
```

## Полиморфизм

```
 GameLoop()
    {
        foreach (Chelovek o in obj)
        o.Walking();
    }
```

Вызываем одну и ту же функцию, которая выполняет одну и ту же задачу. Из этой части программы она выглядит как функция Walking, хотя внутри у нас 3 разных реализации.

## Инкапсуляиця

Все параметры должны находиться внутри объекта. В некоторых языках программирования Сокрытие является частью инкапсуляции (модификаторы доступа паблик, протектед и т.д.).

---

## Не повторяйся (Don’t repeat yourself — DRY)

Избегайте повторного написания кода, вынося в абстракции часто используемые задачи и данные. Каждая часть вашего кода или информации должна находиться в единственном числе в единственном доступном месте. Это один из [принципов читаемого кода](https://tproger.ru/articles/how-to-write-readable-code/).

## Принцип единственной обязанности

Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.

## Принцип открытости/закрытости

Программные сущности должны быть *открыты* для расширения, но *закрыты* для изменений.

## Принцип подстановки Барбары Лисков

Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом.

## Принцип разделения интерфейсов

Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются.

## Принцип инверсии зависимостей

Система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций.
